---
title: "Objective functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Objective functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dpi = 150,
  dev = "png",
  out.width = "100%",
  fig.retina = 2
)
```

```{r, message=FALSE}
library(vistool)
library(plotly)
library(purrr)
set.seed(1)
```

This vignette covers the basic usage of objective functions in `vistool`, including predefined objectives and how to define custom objectives.

## Predefined objectives

The package provides a dictionary of objective functions:

```{r}
as.data.table(dict_objective)
```

To retrieve an objective function:

```{r}
obj_branin = obj("TF_branin")
```

You can evaluate the objective, gradient, and Hessian at a point:

```{r}
x = c(0.9, 1)
obj_branin$eval(x)
obj_branin$grad(x)
obj_branin$hess(x)
```

## Objective transformations

Objective instances can apply scalar transformations to their values while keeping gradients and Hessians consistent.
This is useful when you want to inspect a log-scaled risk surface without re-implementing the underlying model objective.

```{r}
log_design = matrix(c(-1, 0, 1, 2), ncol = 1)
log_response = c(0, 1, 0, 1)

obj_logistic = objective_logistic(log_design, log_response)
obj_logistic_log = objective_logistic(
  log_design,
  log_response,
  transform = objective_transform_log()
)

theta = c(0.2, -0.4)
c(
  identity = obj_logistic$eval(theta),
  log = obj_logistic_log$eval(theta)
)
obj_logistic_log$transform_id

obj_logistic$set_transform(objective_transform_log())
obj_logistic$label
```

## Visualizing objectives

Use `as_visualizer()` to create a visualizer for an objective. For 1D and 2D objectives, the appropriate visualizer is selected automatically.
2D objectives additionally support interactive surface visualization:

```{r, out.width='100%', out.height='700px'}
vis_surface = as_visualizer(obj_branin, type = "surface")
vis_surface$plot()
```

## Custom objectives

You can define your own objective function.
Let's define a loss for a linear model on the iris data with target `Sepal.Width` and feature `Petal.Width`. First, an `Objective` requires a function for evaluation:

```{r}
# Define the linear model loss function as SSE:
l2norm = function(x) sqrt(sum(crossprod(x)))

mylm = function(x, Xmat, y) {
  l2norm(y - Xmat %*% x)
}
```

To fix the loss for the data, the `Objective$new()` call allows to pass custom arguments that are stored and reused in every call to `$eval()` to evaluate `fun`.
So, calling `$eval(x)` internally calls `fun(x, ...)`.
These arguments must be specified just once:

```{r}
# Use the iris dataset with response `Sepal.Width` and feature `Petal.Width`:
Xmat = model.matrix(~Petal.Width, data = iris)
y = iris$Sepal.Width

# Create a new object:
obj_lm = Objective$new(id = "iris LM", fun = mylm, xdim = 2, Xmat = Xmat, y = y, minimize = TRUE)

obj_lm$eval_store(c(1, 2))
obj_lm$eval_store(c(2, 3))
obj_lm$eval_store(coef(lm(Sepal.Width ~ Petal.Width, data = iris)))

obj_lm$archive
```

Visualize the custom objective:

```{r, out.width='100%', out.height='700px'}
vis_lm = as_visualizer(obj_lm, x1_limits = c(-0.5, 5), x2_limits = c(-3.2, 2.8))
vis_lm$add_contours()$plot()
```

You can also add custom points directly to the visualizer using `$add_points()`, which supports many customization options (see below).
For adding actual optimization traces, see the [Optimization & traces vignette](optimization_traces.html).

```{r, out.width='100%', out.height='700px'}
archive_data = data.frame(
  x = sapply(obj_lm$archive$x, function(x) x[1]),
  y = sapply(obj_lm$archive$x, function(x) x[2])
)
vis_lm$add_points(archive_data, color = "orange", size = 3, shape = 17, alpha = 0.8, ordered = TRUE)$plot()
```

*Customization options include: `points` (as data.frame/matrix/list), `color`, `size`, `shape`, `alpha`, `annotations`, `ordered`, and more. See the documentation for all arguments.*

## All 2D objectives

From the [`TestFunctions`](https://CRAN.R-project.org/web/packages/TestFunctions/vignettes/AnIntroductiontoTestFunctions.html) package.

```{r, out.width='100%', out.height='4000px', echo=FALSE}
library(plotly)

tab = as.data.table(dict_objective)
keys = tab[list(2), key, on = "xdim"]
keys = keys[startsWith(keys, "TF_")]

visualizers = map(keys, function(key) {
  objective = obj(key)
  vis = as_visualizer(objective, type = "surface")
  vis$plot(flatten = TRUE, show_title = FALSE) %>%
    add_annotations(
      text = objective$label,
      x = 0.5,
      y = 1,
      yref = "paper",
      xref = "paper",
      xanchor = "center",
      yanchor = "top",
      showarrow = FALSE,
      font = list(size = 15)
    )
})

n_cols = 2L
subplot(
  visualizers,
  nrows = ceiling(length(visualizers) / n_cols),
  shareX = FALSE,
  shareY = FALSE,
  margin = 0.03
) %>%
  layout(showlegend = FALSE)
```

## See also

- [Loss functions](loss_functions.html)
- [Model predictions](model.html)
- [Optimization & traces](optimization_traces.html)
- [Customization guide](customization_guide.html)
- [Advanced visualization](advanced_visualization.html)
